buildscript {
	repositories {
		mavenCentral()
	}

	dependencies {
		classpath "com.discord4j:discord4j-core:3.2.1"
	}
}

import discord4j.common.util.Snowflake
import discord4j.core.DiscordClient
import discord4j.core.event.domain.lifecycle.ReadyEvent
import discord4j.core.object.entity.channel.MessageChannel
import discord4j.core.spec.MessageCreateFields
import reactor.core.publisher.Mono

import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream

def discordFileLimit = 25600;

def splitFile(String name, byte[] file, int maxSize=8192) {
	int parts = (int) Math.ceil((float) file.size() / (1024 * maxSize))
	ByteArrayInputStream[] sections = new ByteArrayInputStream[parts]
	printf("Parts: %s\n", parts)
	for (int i = 0; i < parts; i++) {
		int k = i*maxSize*1024
		byte[] partFile
		if (i == (parts - 1)) {
			partFile = new byte[file.size() - k]
		} else {
			partFile = new byte[maxSize*1024]
		}
		for (int j = 0; j < partFile.size(); j++) {
			partFile[j] = file[k + j]
		}
		printf("Part %s, Size %s\n", i, partFile.size())
		sections[i] = new ByteArrayInputStream(partFile)
	}
	return sections
}
task publishToDiscord() {
	doFirst {
        boolean zipFiles = false;
        def files = new ArrayList<File>()
        fileTree("../build/libs").each {
            if (it.size() > discordFileLimit*1024) {
                zipFiles = true
            }
            files.add(it)
        }
        String name
        InputStream[] sections
        if (zipFiles) {
            ByteArrayOutputStream baOS = new ByteArrayOutputStream()
            ZipOutputStream zOS = new ZipOutputStream(baOS)
            fileTree("../build/libs").each {
                zOS.putNextEntry(new ZipEntry(it.name))
                zOS.write(it.readBytes())
            }
            zOS.close()
            name = "binaries-${System.getenv("BUILD_NUMBER")}"

            println("Reading file...")
            sections = splitFile(name, baOS.toByteArray(), discordFileLimit)

        } else {
            sections = new BufferedInputStream[files.size()]
            for (int i = 0; i < files.size(); i++) {
                sections[i] = files[i].newInputStream()
            }
        }

		def githubRef = System.getenv("WORKFLOW_GITHUB_REF")
		println(githubRef)
		final def token = System.getenv("DISCORD_TOKEN")
		final def client = DiscordClient.create(token)
        final def channelId;
        if (System.getenv("BUILD_NUMBER").startsWith("UNOFFICIAL")) {
            channelId = Long.parseLong(System.getenv("DEV_BUILD_CHANNEL_ID"))
        } else {
            channelId = Long.parseLong(System.getenv("RELEASE_CHANNEL_ID"))
        }
		println("ChannelId: $channelId")
		def login = client.withGateway { gateway ->
			gateway.on(ReadyEvent.class, { event ->
				def self = event.getSelf()
				printf("Logged in as %s#%s%n", self.getUsername(), self.getDiscriminator())

				println("Sending...")
				def channel = (gateway.getChannelById(Snowflake.of(channelId)).block() as MessageChannel)
				println(channel.getType())
				Mono prev = null
				for (int i = 0; i < sections.size(); i++) {

                    String archiveName = zipFiles ? name + ".zip.${String.format("%03d", i + 1)}" : files[i].name

					def content = "Forge Essentials build for Ref\\: `$githubRef` ${ zipFiles ? "part ${i+1}" : "; $archiveName"}"
					println(content)
					Mono cur = channel.createMessage()
							.withContent(content)
							.withFiles(MessageCreateFields.File.of(archiveName, sections[i])).then()
					cur.doOnError({ error ->
						println("Error sending Message")
					})
					if (prev != null) {
						prev &= cur
					} else {
						prev = cur
					}
				}
				return prev
			}).then()
		}
		login.subscribe()
		println("Message Sending...")
		Thread.sleep(15000)
		println("Complete")
	}
}
